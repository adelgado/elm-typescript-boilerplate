<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">

  <title>osiris</title>

  <script type="text/javascript" src="elm.js"></script>
  <!--
  <script type="text/javascript" src="../_reactor/debug.js"></script>

  <link rel="stylesheet" href="./font-awesome/css/font-awesome.min.css">
  <link rel="shortcut icon" href="favicon.ico" />
  -->
  <link rel="stylesheet" href="styles.css">
</head>

<body>

</body>
  <script type="text/javascript">
    if (navigator.requestMIDIAccess) {
        navigator.requestMIDIAccess({
            sysex: false // this defaults to 'false' and we won't be covering sysex in this article. 
        }).then(onMIDISuccess, onMIDIFailure);
    } else {
        alert("No MIDI support in your browser.");
    }

    // midi functions
    function onMIDISuccess(midiAccess) {
        // when we get a succesful response, run this code
        var inputs = midiAccess.inputs.values()

          // iterate through the devices
          for ( var input = inputs.next(); input && !input.done; input = inputs.next() ) {
          console.log( input.value )
        }


        midi = midiAccess; // this is our raw MIDI data, inputs, outputs, and sysex status

        var inputs = midi.inputs.values();
        // loop over all available inputs and listen for any MIDI input
        for (var input = inputs.next(); input && !input.done; input = inputs.next()) {
            // each time there is a midi message call the onMIDIMessage function
            input.value.onmidimessage = onMIDIMessage;
        }
    }

    function onMIDIMessage(event) {
        data = event.data,
        cmd = data[0] >> 4,
        channel = data[0] & 0xf,
        type = data[0] & 0xf0, // channel agnostic message type. Thanks, Phil Burk.
        note = data[1],
        velocity = data[2];

        switch (type) {
            case 144: // noteOn message 
                 noteOn(note, velocity);
                 break;
            case 128: // noteOff message 
                noteOff(note, velocity);
                break;
        }

       // logger("breno", 'key data', data);
    }

    var oscillators = []

    function noteOn(midiNote, velocity) {
      var osc1 = context.createOscillator()
      oscillators[midiNote] = [osc1]


      osc1.frequency.value = frequencyFromNoteNumber(midiNote)
      osc1.type = 'sawtooth'
      osc1.connect( masterVolume )
      osc1.start( context.currentTime )

    }

    function noteOff(midiNote, velocity) {
        player(midiNote, velocity);
    }

    function player(note, velocity) {
      console.log(note)
      console.log(velocity)
    }

    function onMIDIFailure(e) {
        log("No access to MIDI devices or your browser doesn't support WebMIDI API. Please use WebMIDIAPIShim " + e);
    }


    // utility functions


    function frequencyFromNoteNumber(note) {
        return 440 * Math.pow(2, (note - 69) / 12);
    }

    function logger(container, label, data) {
        messages = label + " [channel: " + (data[0] & 0xf) + ", cmd: " + (data[0] >> 4) + ", type: " + (data[0] & 0xf0) + " , note: " + data[1] + " , velocity: " + data[2] + "]";

        console.log(messages)
    }

    var app = Elm.Main.fullscreen()

    var context = new AudioContext


    var masterVolume = context.createGain()

    masterVolume.gain.value = 0.2

    masterVolume.connect( context.destination )



    app.ports.noteOn.subscribe(function(data) {
      var note = [0]
      var velocity = [1]
      noteOn(note, velocity)

    });

  </script>
</html>